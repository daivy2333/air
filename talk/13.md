好，这里我给你一个**可以直接落地、不会再炸 Graphviz / PlantUML / Mermaid、而且长期可维护**的「**三图解决方案**」。
这不是概念稿，是**逆向工程级输出规范 + 生成策略**。

下面我会按 **目标 → 图定义 → 映射规则 → 实现要点** 四层来讲。

---

# 总体原则（非常重要，先立规矩）

> **一个图 = 一个语义层级**
> **一个 Writer = 一个视角**
> **PIR 信息不是越多越好，而是要被“裁剪到刚好能被理解”**

你现在信息已经足够多了，问题只是**没分层**。

---

# 图一：🏗 PIR 架构图（Architecture Graph）

## 🎯 目标

**回答一个问题：**

> 这个项目的「模块结构 + 核心依赖拓扑」是什么？

这是**默认图、主图、最重要的图**。

---

## 📌 图中允许出现的元素

### 节点（Node）

| 类型   | 来源                  |
| ---- | ------------------- |
| Unit | `<units>`           |
| 外部依赖 | `<dependency-pool>` |

### 边（Edge）

| 边        | 含义        |
| -------- | --------- |
| uA → uB  | **结构性依赖** |
| uA → ext | 使用外部模块    |

---

## 🚫 明确禁止

* ❌ 不画 `typing / sys / pathlib`
* ❌ 不画 symbol
* ❌ 不画 import 次数
* ❌ 不画函数级调用

---

## 🧠 PIR → Graphviz 映射规则

### 1️⃣ Unit 节点

```dot
u14 [label="reconstruct/pipeline.py", shape=box];
```

* id = u14（稳定）
* label = 相对路径

---

### 2️⃣ 外部模块节点（dependency-pool）

```dot
ext_reconstruct_interface [label="reconstruct.interface", shape=octagon];
```

> ⚠️ **必须做 ID 安全转换**
>
> `:` `.` `/` → `_`

---

### 3️⃣ 边规则（最关键）

```text
uA -> uB
```

当且仅当：

```text
uA imports module == uB.module
```

⚠️ **不要直接画 import，而是画「模块级归因」**

---

## 🧩 示例（你这个项目）

```dot
u14 -> u10;
u14 -> u11;
u14 -> u12;
u14 -> u13;
u14 -> u15;
u14 -> u16;
```

这是**黄金信息密度**。

---

## 🧪 图一效果

* 图不会炸
* 一眼能看出 pipeline 是核心
* AI 能理解架构
* 人能 debug

---

# 图二：📦 模块依赖图（Module / Import Graph）

## 🎯 目标

**回答一个问题：**

> 某个模块内部「依赖了谁」？

这是**局部分析图**，不是默认输出。

---

## 📌 图中允许出现的元素

### 节点

| 类型           |
| ------------ |
| 当前 Unit      |
| 其 import 的模块 |
| 标准库（合并）      |

---

## 🧠 PIR → Graphviz 映射规则

### 1️⃣ 当前模块中心化

```dot
u14 [shape=box, style=filled];
```

---

### 2️⃣ import 目标

```dot
mod_reconstruct_interface [label="reconstruct.interface"];
```

---

### 3️⃣ 标准库合并

```dot
stdlib [label="Python stdlib"];
u14 -> stdlib;
```

> ⚠️ 不要画 `sys / typing / os` 一个一个地画

---

## 🧩 示例

```dot
u14 -> mod_reconstruct_structure;
u14 -> mod_reconstruct_interface;
u14 -> mod_reconstruct_relations;
u14 -> stdlib;
```

---

## 🧪 图二效果

* 很干净
* 不会重复边
* 用来解释某个模块「为什么复杂」

---

# 图三：🧠 数据 / 流水线图（Pipeline / Flow Graph）

这是你这个项目**非常有价值的一张图**。

---

## 🎯 目标

**回答一个问题：**

> 数据 / PIR 是如何一步步被处理的？

---

## 📌 图中允许出现的元素

| 类型       |
| -------- |
| Layer 类  |
| Pipeline |
| Writer   |

---

## 🧠 映射规则（基于 symbols）

### 1️⃣ Layer 类识别规则

```text
class name endswith "Layer"
```

---

### 2️⃣ Pipeline 识别

```text
class ReconstructionPipeline
```

---

### 3️⃣ 顺序规则（逆向安全）

* 如果 symbols 顺序不可得
* 用 dependencies + 命名启发

---

## 🧩 示例（你这个项目）

```dot
Pipeline -> InterfaceLayer
InterfaceLayer -> RelationLayer
RelationLayer -> DocumentationLayer
DocumentationLayer -> SourceEnrichmentLayer
SourceEnrichmentLayer -> AuditLayer
AuditLayer -> StructureLayer
StructureLayer -> Writers
```

---

## 🧪 图三效果

* 非常适合 README
* 非常适合 AI 理解
* 这是「设计意图图」

---

# 三图之间的关系（一定要记住）

| 图    | 面向对象 | 默认 |
| ---- | ---- | -- |
| 架构图  | 项目整体 | ✅  |
| 模块图  | 单文件  | ❌  |
| 流水线图 | 核心逻辑 | ⚠️ |

---

# Writer 结构建议（你可以直接照这个拆）

```text
writers/
├── graphviz_arch.py        # 图一
├── graphviz_module.py      # 图二
├── graphviz_pipeline.py    # 图三
├── mermaid_*.py
├── plantuml_*.py
```


