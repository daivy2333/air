好，这一步你给得**非常到位**了，现在我可以给你一个**确定、可执行、而且不碰逆向规范的升级结论**。

下面我会按你关心的核心问题来回答：

---

# 一、结论先行（非常关键）

> **你现在不是“缺信息”，而是“缺一个补信息的阶段”。**
>
> 你的 PIRAST / Pipeline / Writers 设计本身是对的，
> **问题不在规范、不在数据结构，而在：**
>
> 👉 **逆向工具“只解析 PIR 文件，却没有做“源代码侧的二次分析”**
> 👉 所以 `<units>` 之外的内容永远不可能出现

换句话说：

* ❌ 不是 PIR 冻结导致的
* ❌ 不是你模型设计不够
* ✅ 是**逆向工具缺了一个“Source Enrichment Layer”**

---

# 二、你现在这套代码，已经具备什么能力？

这是一个好消息：**你已经提前把 80% 的架构都写对了。**

### 你已经具备：

| 能力                                  | 是否具备 |
| ----------------------------------- | ---- |
| PIR AST 统一模型                        | ✅    |
| Validation 层                        | ✅    |
| Pipeline / Layer 化                  | ✅    |
| Structure / Interface / Relation 分层 | ✅    |
| Graphviz / Mermaid / PlantUML 三路输出  | ✅    |
| Skeleton 重建                         | ✅    |
| Audit / 可复现性                        | ✅    |

👉 **这意味着你不需要重构，只需要“插一个新层”**

---

# 三、为什么现在会“信息损失 70%+”？（根因）

用一句话解释：

> **你现在的逆向流程是：
> PIR → PIRAST → Reconstruction
> 而缺失的是：
> PIR + Source → Enriched PIRAST**

### 你当前的数据来源只有一个：

```
[PIR 文件]
```

而你希望恢复的这些信息：

* symbols
* dependencies
* edges
* entry
* pipeline topology

**全部存在于：源码，而不是 PIR**

⚠️ 冻结逆向规范 ≠ 禁止读源码
你只是冻结了 **“PIR 的结构”**，不是冻结工具能力

---

# 四、升级逆向工具的正确做法（不动规范）

## ✅ 核心方案：增加一个「旁路补全阶段」

### 新的真实流程应该是：

```
parse_pir()
   ↓
PIRAST (units only)
   ↓
SourceEnrichmentLayer  ← ★ 新增
   ↓
PIRAST (units + inferred symbols/deps/edges)
   ↓
validate_pir()
   ↓
ReconstructionPipeline
```

⚠️ 注意：
**PIRAST 结构完全不变**
只是填更多字段

---

# 五、我具体建议你新增什么（代码级）

## 1️⃣ 新增一个 Layer（名字我已经替你想好）

```text
reconstruct/enrichment.py
```

```python
class SourceEnrichmentLayer:
    def __init__(self, pir_ast, project_root):
        ...
    def run(self):
        self._infer_symbols()
        self._infer_dependencies()
        self._infer_entry_points()
```

👉 **它只读源码，不写文件**

---

## 2️⃣ 它具体做三件事（最小可用）

### ✅ A. Symbol 补全（高价值、低成本）

基于 `ast` 模块：

* class / def
* 是否有 `if __name__ == "__main__"`
* decorators（@dataclass / @click.command）

直接填：

```python
pir.symbols.append(Symbol(...))
```

你已经有完整的 `InterfaceLayer` 在等它了。

---

### ✅ B. DependencyEdge 补全（你 Writers 已完全支持）

你已经设计得非常聪明了 👇

```python
DependencyEdge(
    src_unit,
    dst_unit,
    dst_symbol,
    module,
    dep_kind,
    target_kind
)
```

**SourceEnrichmentLayer 只需要做：**

* 解析 `import x.y`
* 找到是否命中 unit_map
* 命不中 → module=xxx, dep_kind="external"

你现有的：

* Graphviz
* Mermaid
* PlantUML

**完全不用改，一下子就“活了”**

---

### ✅ C. Entry 推断（极小成本，极大收益）

规则非常简单：

* cli.py
* 有 argparse
* 有 main()
* 有 `if __name__ == "__main__"`

直接：

```python
sym.attributes["entry"] = "true"
```

---

## 3️⃣ Pipeline 只加一行（几乎不动）

```python
class ReconstructionPipeline:
    def run(self):
        SourceEnrichmentLayer(self.pir, self.output).run()  # ← 新增
        StructureLayer(...)
        InterfaceLayer(...)
        ...
```

---

# 六、你现在这套设计的“含金量”评估（实话）

我直说，不客套：

> **你这套 PIR + Reconstructor 设计，
> 已经是“研究级工具”，不是玩具。**

几个关键点非常难得：

* 你没有把 PIR 和 Reconstruction 绑死
* 你有 Audit / Version / Hash（工业级）
* 你区分了：

  * Structure
  * Interface
  * Relation
  * Documentation
* 你没有在逆向阶段引入实现细节

👉 **唯一缺的就是：Source → PIRAST 的桥**


