# reconstruct/layout.py
"""
RISC-V 内存布局处理模块

根据 PIR 中的 <layout> 信息生成正确的链接器脚本，
处理内存段布局，生成入口点和符号定义。
"""

from typing import Dict, List, Optional
from dataclasses import dataclass
from ..pir.model import PIRAST, Unit, Symbol


@dataclass
class MemoryRegion:
    """内存区域定义"""
    name: str
    origin: str  # 起始地址，如 "0x80000000"
    length: str  # 长度，如 "128K"
    attributes: str = ""  # 属性，如 "rwx"


@dataclass
class Section:
    """段定义"""
    name: str  # 段名，如 ".text", ".data"
    region: str  # 所属区域
    align: Optional[int] = None  # 对齐
    flags: Optional[str] = None  # 标志


class RISCVLayoutGenerator:
    """RISC-V 链接器脚本生成器"""

    # RISC-V 常见内存区域
    DEFAULT_REGIONS = {
        'ram': MemoryRegion('ram', '0x80000000', '128K', 'wxa!ri'),
        'rom': MemoryRegion('rom', '0x20000000', '32K', 'rx!w'),
    }

    # RISC-V 常见段定义
    DEFAULT_SECTIONS = [
        Section('.text', 'ram', 4, 'ax'),
        Section('.rodata', 'ram', 4, 'a'),
        Section('.data', 'ram', 4, 'wa'),
        Section('.bss', 'ram', 4, 'wa'),
        Section('.stack', 'ram', 16, 'wa'),
        Section('.heap', 'ram', 16, 'wa'),
    ]

    def __init__(self, pir: PIRAST, project_root: str):
        self.pir = pir
        self.project_root = project_root
        self.regions: Dict[str, MemoryRegion] = {}
        self.sections: List[Section] = []
        self.entry_point: Optional[str] = None
        self.symbols: Dict[str, str] = {}  # 符号名 -> 值

    def generate(self) -> str:
        """生成完整的链接器脚本"""
        self._parse_layout_info()
        self._infer_defaults()

        return self._generate_linker_script()

    def _parse_layout_info(self):
        """从 PIR 中解析布局信息"""
        # 从 layout_lines 中提取布局信息
        for line in getattr(self.pir, 'layout_lines', []):
            if line.startswith('ENTRY='):
                self.entry_point = line.split('=', 1)[1]
            elif line.startswith('BASE='):
                base = line.split('=', 1)[1]
                if 'ram' not in self.regions:
                    self.regions['ram'] = MemoryRegion('ram', base, '128K', 'wxa!ri')
            elif line.startswith('SECTIONS='):
                sections_str = line.split('=', 1)[1]
                section_names = sections_str.split(',')
                for name in section_names:
                    if name.startswith('.'):
                        self.sections.append(Section(name, 'ram'))

    def _infer_defaults(self):
        """推断默认值"""
        # 如果没有定义区域，使用默认区域
        if not self.regions:
            self.regions = self.DEFAULT_REGIONS.copy()

        # 如果没有定义段，使用默认段
        if not self.sections:
            self.sections = self.DEFAULT_SECTIONS.copy()

        # 如果没有定义入口点，尝试从符号中查找
        if not self.entry_point:
            for sym in self.pir.symbols:
                if sym.name == '_start':
                    self.entry_point = sym.name
                    break

    def _generate_linker_script(self) -> str:
        """生成链接器脚本内容"""
        lines = []

        # 文件头
        lines.append("/* RISC-V Linker Script */")
        lines.append("/* Generated by PIR Reconstructor */")
        lines.append("")

        # 内存区域定义
        lines.append("/* Memory Regions */")
        for name, region in self.regions.items():
            lines.append(f"MEMORY {{")
            lines.append(f"    {name} (origin = {region.origin}, length = {region.length}) : {region.attributes}")
            lines.append(f"}}")
        lines.append("")

        # 入口点
        if self.entry_point:
            lines.append(f"ENTRY({self.entry_point})")
            lines.append("")

        # 段定义
        lines.append("/* Sections */")
        lines.append("SECTIONS")
        lines.append("{")

        for section in self.sections:
            lines.append(f"    {section.name} : {{")
            if section.align:
                lines.append(f"        . = ALIGN({section.align});")
            lines.append(f"        *(.{section.name})")
            lines.append(f"        *(.{section.name}*)")
            if section.align:
                lines.append(f"        . = ALIGN({section.align});")
            lines.append(f"    }} > {section.region}")
            lines.append("")

        # 添加特殊符号
        lines.append("    /* Special Symbols */")
        lines.append("    _stack_start = .;")
        lines.append("    . += 0x1000;  /* 4KB stack */")
        lines.append("    _stack_end = .;")
        lines.append("")
        lines.append("    _heap_start = .;")
        lines.append("    _heap_end = ORIGIN(ram) + LENGTH(ram);")

        lines.append("}")

        return "\n".join(lines)


def generate_riscv_linker_script(pir: PIRAST, project_root: str) -> str:
    """
    生成 RISC-V 链接器脚本的便捷函数

    Args:
        pir: PIR AST 对象
        project_root: 项目根目录路径

    Returns:
        生成的链接器脚本内容
    """
    generator = RISCVLayoutGenerator(pir, project_root)
    return generator.generate()


def extract_memory_layout(pir: PIRAST) -> Dict[str, any]:
    """
    从 PIR 中提取内存布局信息

    Args:
        pir: PIR AST 对象

    Returns:
        包含内存布局信息的字典
    """
    layout = {
        'regions': {},
        'sections': [],
        'entry_point': None,
        'symbols': {}
    }

    for line in getattr(pir, 'layout_lines', []):
        if line.startswith('ENTRY='):
            layout['entry_point'] = line.split('=', 1)[1]
        elif line.startswith('BASE='):
            layout['base'] = line.split('=', 1)[1]
        elif line.startswith('SECTIONS='):
            sections_str = line.split('=', 1)[1]
            layout['sections'] = sections_str.split(',')

    return layout
