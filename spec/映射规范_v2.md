# PIR 可视化映射规范 v2

## 一、总体原则

> **一个图 = 一个语义层级**
> **一个 Writer = 一个视角**
> **PIR 信息不是越多越好，而是要被"裁剪到刚好能被理解"**

## 二、三种图的定义

### 图一：🏗 PIR 架构图（Architecture Graph）

**目标**：回答"这个项目的「模块结构 + 核心依赖拓扑」是什么？"

这是**默认图、主图、最重要的图**。

**图中允许出现的元素**：

| 节点类型 | 来源 |
| --------- | ------ |
| Unit | `<units>` |
| 外部依赖 | `<dependency-pool>` |

**边**：

| 边 | 含义 |
| --- | --- |
| uA → uB | **结构性依赖** |
| uA → ext | 使用外部模块 |

**明确禁止**：
- ❌ 不画 `typing / sys / pathlib`
- ❌ 不画 symbol
- ❌ 不画 import 次数
- ❌ 不画函数级调用

**PIR → Graphviz 映射规则**：

1. Unit 节点：
   ```dot
   u14 [label="reconstruct/pipeline.py", shape=box, style=filled, fillcolor="#cce5ff"];
   ```
   - id = u14（稳定）
   - label = 相对路径

2. 外部模块节点（dependency-pool）：
   ```dot
   ext_reconstruct_interface [label="reconstruct.interface", shape=octagon];
   ```
   - 必须做 ID 安全转换：`:` `.` `/` → `_`

3. 边规则（最关键）：
   ```dot
   uA -> uB
   ```
   当且仅当：
   ```text
   uA imports module == uB.module
   ```
   不要直接画 import，而是画「模块级归因」

**示例**：
```dot
u14 -> u10;
u14 -> u11;
u14 -> u12;
u14 -> u13;
u14 -> u15;
u14 -> u16;
```

---

### 图二：📦 模块依赖图（Module / Import Graph）

**目标**：回答"某个模块内部「依赖了谁」？"

这是**局部分析图**，不是默认输出。

**图中允许出现的元素**：

| 节点类型 | 说明 |
| --------- | ---- |
| 当前 Unit | 按模块分组 |
| 其 import 的模块 | |
| 标准库（合并） | |

**PIR → Graphviz 映射规则**：

1. 当前模块中心化：
   ```dot
   u14 [shape=box, style=filled];
   ```

2. import 目标：
   ```dot
   mod_reconstruct_interface [label="reconstruct.interface"];
   ```

3. 标准库合并：
   ```dot
   stdlib [label="Python stdlib"];
   u14 -> stdlib;
   ```
   不要画 `sys / typing / os` 一个一个地画

**示例**：
```dot
u14 -> mod_reconstruct_structure;
u14 -> mod_reconstruct_interface;
u14 -> mod_reconstruct_relations;
u14 -> stdlib;
```

---

### 图三：🧠 数据 / 流水线图（Pipeline / Flow Graph）

**目标**：回答"数据 / PIR 是如何一步步被处理的？"

这是**非常有价值的一张图**。

**图中允许出现的元素**：

| 类型 | 说明 |
| ---- | ---- |
| Layer 类 | 识别规则：class name endswith "Layer" |
| Pipeline | 识别：class ReconstructionPipeline |
| Writer | 识别：class name contains mermaid/graphviz/plantuml/filesystem |

**映射规则（基于 symbols）**：

1. Layer 类识别规则：
   ```text
   class name endswith "Layer"
   ```

2. Pipeline 识别：
   ```text
   class ReconstructionPipeline
   ```

3. 顺序规则（逆向安全）：
   - 如果 symbols 顺序不可靠
   - 用 dependencies + 命名启发

**示例**：
```dot
Pipeline -> InterfaceLayer;
InterfaceLayer -> RelationLayer;
RelationLayer -> DocumentationLayer;
DocumentationLayer -> SourceEnrichmentLayer;
SourceEnrichmentLayer -> AuditLayer;
AuditLayer -> StructureLayer;
StructureLayer -> Writers;
```

---

## 三、三图之间的关系

| 图 | 面向对象 | 默认 |
| --- | ---- | -- |
| 架构图 | 项目整体 | ✅ |
| 模块图 | 单文件 | ❌ |
| 流水线图 | 核心逻辑 | ⚠️ |

---

## 四、Writer 结构建议

```text
writers/
├── graphviz_arch.py        # 图一：架构图
├── graphviz_module.py      # 图二：模块依赖图
├── graphviz_pipeline.py    # 图三：流水线图
├── mermaid_*.py          # Mermaid 输出（兼容）
└── plantuml_*.py         # PlantUML 输出（兼容）
```

---

## 五、确定性规则

### 输出顺序

1. 节点顺序：
   - Units按ID升序 (u0, u1, u2...)
   - Modules按字母顺序
   - Layers按执行顺序

2. 边顺序：
   - 按<dependencies>区块中声明顺序
   - 同一单元的多行按出现顺序

### 标签生成规则

节点标签必须保持原始格式：
- Unit: 完整unit.path
- Module: 模块名
- Symbol: 原始符号名
- External: 原始external字符串

---

## 六、验证要求

### 节点验证

- 检查Unit节点数量
- 检查每个Unit节点都存在
- 检查External节点

### 边验证

- 检查边数量
- 检查每条边都有对应依赖
- 检查无重复边

---

## 七、实现一致性要求

### 三端一致性

对于同一PIR输入，必须保证：
1. 节点集合相同：所有图的节点ID集合必须一致
2. 边集合相同：源-目标-类型三元组必须相同
3. 标签相同：对应节点的标签文本必须相同

### 可验证的确定性

```python
def test_determinism(pir_content: str):
    """测试可视化确定性"""
    # 解析PIR
    pir = parse_pir(pir_content)

    # 生成三种可视化
    arch = emit_arch_graph(pir)
    module = emit_module_graph(pir)
    pipeline = emit_pipeline_graph(pir)

    # 验证节点集合
    arch_nodes = extract_nodes(arch)
    module_nodes = extract_nodes(module)
    pipeline_nodes = extract_nodes(pipeline)

    # 验证各自符合规范
    assert validate_arch_graph(arch_nodes)
    assert validate_module_graph(module_nodes)
    assert validate_pipeline_graph(pipeline_nodes)
```

---

## 八、禁止行为清单

### 节点相关禁止：
- ❌ 自动分组或聚类unit节点
- ❌ 基于module创建虚拟节点（架构图中）
- ❌ 省略未连接的节点
- ❌ 重命名节点标签

### 边相关禁止：
- ❌ 合并重复边
- ❌ 推断传递依赖
- ❌ 省略间接依赖
- ❌ 改变依赖类型

### 布局相关禁止：
- ❌ 基于语义重新排列节点
- ❌ 自动调整层级关系
- ❌ 隐藏特定类型的节点
- ❌ 添加未声明的边类型

---

## 九、设计哲学

本可视化映射规范遵循**投影而非解释**原则：
- 图是PIR关系的忠实投影
- 不添加未在PIR中声明的信息
- 不删除已在PIR中声明的信息
- 不改变PIR中关系的语义

可视化目标是辅助理解项目结构，而不是推断项目语义。
